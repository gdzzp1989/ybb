~~CAP理论：一个分布式系统不可能同时满足一致性（C:Consistency）、可用性（A:Availability）和分区容错性（P:Partition tolerance）
           这三个基本需求，最多只能同时满足其中的两项。
	   一致性：数据在多个服务之间能够保持一致性
           可用性：系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果
	   分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务

~~BASE理论：BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，
	    BASE是对CAP中一致性和可用性权衡的结果
	    基本可用：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性（响应时间变长，降级等）
	    软状态：允许系统在不同服务的数据之间进行数据同步的过程存在延时
	    最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态

~~Paxos算法：基于一大堆完全不可靠的网络条件下却能可靠确定地实现共识一致性的算法
           Paxos的三种角色：
		Proposer：提出提案等待大家认可该提案为决议。(系统中的提案都拥有一个自增的唯一提案号，<往往由客户端担任该角色>)。
		Acceptor：负责对提案进行投票，认可提案。<往往由服务器担任该角色>
		Learner：获取批准的结果 （学习acceptor所认可的结果），并帮忙传播，不参与投票过程。<客户端和服务器担任>
	   Paxos的流程：分为两个阶段，准备阶段、提交阶段。
	        准备阶段：
			proposer向网络内超过半数的acceptor发送prepare消息 (即：提交自己的提案编号)
			acceptor正常情况下回复promise消息（接受者时可保存收到过的提案的最大编号和认可的最大提案，如果收到的提案号比自己保留的最大提案号还大，
			    则返回自己已认可的提案号；如果从未认可过提案，则返回空，并更新当前保存的最大提案号，并说明不再认可小于最大提案号的提案）
		提交阶段：
			proposer收到超过一半acceptor回复promise消息后，proposer向Acceptor发送提案号和提案内容
			acceptor收到proposer发来的信息，如果发现提案号小于自己保存的当前已接收的最大提案号，则返回proposer Rejected和已经接受的提案号和提案内容
			                                如果发现提案号大于等于自己保存的当前已接收的最大提案号，则返回proposer accepted 并认可的最大提案，并更新认可提案内容

一旦多数接受者认可了共同提案值，则形成决议，成为最终确认。



具体例子：

1） 参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）；
2） 3个将军收到参谋1的提议，由于之前还没有保存任何编号，因此把（编号1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（ok）；
3） 参谋1收到至少2个将军的回复，再次派通信兵带信给3个将军，内容为（编号1，进攻时间1）；
4） 3个将军收到参谋1的时间，把（编号1，进攻时间1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（Accepted）；
5） 参谋1收到至少2个将军的（Accepted）内容，确认进攻时间已经被大家接收；
6） 参谋2发起提议，派通信兵带信给3个将军，内容为（编号2）；
7） 3个将军收到参谋2的提议，由于（编号2）比（编号1）大，因此把（编号2）保存下来，避免遗忘；又由于之前已经接受参谋1的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）；
8） 参谋2收到至少2个将军的回复，由于回复中带来了已接受的参谋1的提议内容，参谋2因此不再提出新的进攻时间，接受参谋1提出的时间



1） 参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）；
2） 3个将军的情况如下
	a) 将军1和将军2收到参谋1的提议，将军1和将军2把（编号1）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）；
	b) 负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议；
3） 参谋2在同一时间也发起了提议，派通信兵带信给3个将军，内容为（编号2）；
4） 3个将军的情况如下
	a) 将军2和将军3收到参谋2的提议，将军2和将军3把（编号2）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）；
	b) 负责通知将军1的通信兵被抓，因此将军1没收到参谋2的提议；
5） 参谋1收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号1，进攻时间1）；
6） 2个将军的情况如下
	a) 将军1收到了（编号1，进攻时间1），和自己保存的编号相同，因此把（编号1，进攻时间1）保存下来；同时让通信兵带信回去，内容为（Accepted）；	
	b) 将军2收到了（编号1，进攻时间1），由于（编号1）小于已经保存的（编号2），因此让通信兵带信回去，内容为（Rejected，编号2）；
7） 参谋2收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号2，进攻时间2）；
8） 将军2和将军3收到了（编号2，进攻时间2），和自己保存的编号相同，因此把（编号2，进攻时间2）保存下来，同时让通信兵带信回去，内容为（Accepted）；
9） 参谋2收到至少2个将军的（Accepted）内容，确认进攻时间已经被多数派接受；
10） 参谋1只收到了1个将军的（Accepted）内容，同时收到一个（Rejected，编号2）；参谋1重新发起提议，派通信兵带信给3个将军，内容为（编号3）；
11） 3个将军的情况如下
	a) 将军1收到参谋1的提议，由于（编号3）大于之前保存的（编号1），因此把（编号3）保存下来；由于将军1已经接受参谋1前一次的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）；
	b) 将军2收到参谋1的提议，由于（编号3）大于之前保存的（编号2），因此把（编号3）保存下来；由于将军2已经接受参谋2的提议，因此让通信兵带信回去，内容为（编号2，进攻时间2）；
	c) 负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议；
12） 参谋1收到了至少2个将军的回复，比较两个回复的编号大小，选择大编号对应的进攻时间作为最新的提议；参谋1再次派通信兵带信给有答复的2个将军，内容为（编号3，进攻时间2）；
13） 将军1和将军2收到了（编号3，进攻时间2），和自己保存的编号相同，因此保存（编号3，进攻时间2），同时让通信兵带信回去，内容为（Accepted）；
14） 参谋1收到了至少2个将军的（accepted）内容，确认进攻时间已经被多数派接受；


~~Raft算法：raft是paxos的改进版，在raft中首先具备了三种角色：Leader (领导者)、Candidate （候选者）、Follower （追随者）；
   通常再做决策之前需要选举出一个全局的Leader来简化后续的决策过程。Leader决定了log的提交，且 log只能是Leader 想follower单向提交。<此处的log指的是各种事件发生记录>
   角色：
	Leader (领导者)：负责接收客户端的Log，并分发给其他节点。
	Candidate （候选者）：发起选举请求，竞争Leader。
	Follower （追随者）：负责接收Leader发送过来的Log，并刷新保存。

   Raft 分为两个过程：选举Leader、日志同步。
