~~DDL数据定义语言，不可以回滚
  DML数据操纵语言，可以回滚

~~数据库范式
  1NF:每一列都是不可分割的原子数据项
  2NF：1NF+非主属性完全依赖于关键字
  3NF：2NF+非主属性不依赖于其它非主属性
  BCNF：3NF+非主属性不能对主键子集依赖
  4NF：消除多对多关系
 
~~数据库优化法则
  1.减少数据访问：索引
  2.返回更少数据：分页，只查询所需要的数据
  3.减少交互次数：fetch size，存储过程，批量提交
  4.减少数据库运算：使用绑定变量
  5.利用更少资源：多线程


~~Oracle的优化器,数据库引擎在执行sql语句时的优化策略
    RBO：基于规则的优化,不关心访问表的数据分布情况，仅仅凭借规则经验来确定，所以说是一种比较粗放的优化策略。
    CBO: 基于代价的优化:CBO会根据统计信息来生成一组可能被使用到的执行计划，进而估算出每个计划的代价，从而选择出代价最小的交给执行器去执行


~~聚集索引：一个表只能有一个，存储的数据按照索引的顺序排序，适用返回某范围内的数据
  非聚集索引：非聚集索引一个表可以存在多个，通过指针指向数据，适用频繁更新的列

  索引在数据库中是以表的形式存储的，太多的索引会增加开销，
  索引并不是一劳永逸的,用的时间长了需要进行整理或者重建

~~事务的四个特性：原子性，一致性，隔离性，持久性

~~脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
  不可重复读是指对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，
            被另一个事务修改并提交了。
  虚读(幻读)：和不可重复读类似，不可重复读重点在于update和delete，而幻读的重点在于insert。
               （在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据）

~~数据库锁机制：表锁定和行锁定

~~只读事务：只读取数据的事务，不能写操作

~~数据库四种隔离级别：sqlserver（DBCC USEROPTIONS），
   Serializable (串行化)：事务只能一个个执行，可避免脏读、不可重复读、幻读的发生。(范围锁)
   Repeatable read (可重复读)：读取事务允许读取事务，不许写事务，可避免脏读、不可重复读的发生。但会有幻读
   Read committed (读已提交/授权读取)：被读取的数据可以被其他事务修改，可避免脏读的发生。但会有不可重复读和幻读
   Read uncommitted (读未提交/未授权读取)：最低级别，允许其他事务看到没有提交的数据，任何情况都无法保证。

~~索引失效情况
  select *，可能会导致不走索引(优化器会优化成全表扫描)
  索引列上有函数运算，导致不走索引
  隐式转换导致不走索引(字段为varchar，但是查询没加引号)
  like的模糊查询以%开头，索引失效
  条件中用or时，只要有一列不是索引字段，则索引失效


~~有 Index (A,B,C) ——组合索引多字段是有序的，并且是个完整的BTree 索引。
    下面条件可以用上该组合索引查询：
	A>5
	A=5 AND B>6
	A=5 AND B=6 AND C=7
	A=5 AND B IN (2,3) AND C>5
    下面条件将不能用上组合索引查询：
	B>5 ——查询条件不包含组合索引首列字段
	B=6 AND C=7 ——查询条件不包含组合索引首列字段
    下面条件将能用上部分组合索引查询：
	A>5 AND B=2 ——当范围查询使用第一列，查询条件仅仅能使用第一列
	A=5 AND B>6 AND C=2 ——范围查询使用第二列，查询条件仅仅能使用前二列

~~有组合索引 Index(A,B)。
    下面条件可以用上组合索引排序：
	ORDER BY A——首列排序
	A=5 ORDER BY B——第一列过滤后第二列排序
	ORDER BY A DESC, B DESC——注意，此时两列以相同顺序排序
	A>5 ORDER BY A——数据检索和排序都在第一列
     下面条件不能用上组合索引排序：
	ORDER BY B ——排序在索引的第二列
	A>5 ORDER BY B ——范围查询在第一列，排序在第二列
	A IN(1,2) ORDER BY B ——理由同上
	ORDER BY A ASC, B DESC ——注意，此时两列以不同顺序排序

~~count(1):等于count(*)
  count(*)是针对于全表的，如果索引列是非空的，那么和count(列)一样快，如果是为空的，比count(列)慢
  count(列)是针对于某一列的，如果此列值为空的话，count(列)是不会统计这一行的，可以用到索引

~~扇区： 硬盘的最小读写单元，通常是512字节，512byte
  块/簇： 是操作系统针对硬盘读写的最小单元
  page： 是内存与操作系统之间操作的最小单元

~~索引类型
    哈希表
    有序数组
    二叉树
    N叉树
    BitMap索引使用不同的值进行分组，然后每组数据中将相同的值的位置标位1，不同的值的位置标为0

~~主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
  非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引,回到主键索引树搜索的过程，我们称为回表

~~覆盖索引: 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖

~~索引下推ICP：可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数
            例：select * from user_table where username like '张%' and age > 10
            联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。


~~~~Mysql索引底层数据结构：B+树  加强型多路平衡查找树：绝对平衡的树
    不采用平衡二叉树的原因：数据量大的情况下深度太深导致IO次数太多
                            每次IO的时候返回的数据量太小（IO已页为单位（4kb），但是一个节点的数据量远远小于4kb）

    B+相对于B树的优势： 1.数据全部存在叶子节点，叶子节点之间都引用关系，
                         所以对于扫表和范围查询更快，子节点存的都是引用，io更快
                       2.由于数据都在叶子节点，查询效率更加稳定(不会不同查询查询的节点不同)

    InnoDB：采用主键索引（没有主键mysql自动创建用户不可见的主键），有多字段索引时，其他字段建辅助索引，先去辅助索引找到主键值，再去主键索引找到具体值
    MyISAM：多字段索引是同级别的

    离散性（值的不重复比例）越高，索引查询效率越高
    InnoDB存储的基本构建Page，Page组成一个双向链表，Page单个大小16K，结构：头部，内容，尾部，数据和索引都存在User Records中（共有4种Record类型）

~~Mysql分析sql语句：explain

~~Mysql多表连接查询方式
    Hash Join:Mysql8.0新特性
    Block Nested Loop


~~Mysql 表级锁:lock tables … read/write。释放锁的语法 unlock tables
                MDL锁：metadata lock（元数据锁),MDL不需要显式使用，对表结构变更的时候，加MDL写锁

~~Mysql垂直切分和水平切分（分库分表）


~~Mysql存储引擎
  InnoDB  创建的表的表结构存储在.frm文件中。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中
          提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全，但是读写效率较差，占用的数据空间相对较大
  MyISAM： MyISAM的表存储成3个文件，拓展名为frm（表的结构）、MYD（存储数据）、MYI（存储索引）
          占用空间小，处理速度快。缺点是不支持事务的完整性和并发性
  MEMORY: 创建的表对应一个磁盘文件。类型为frm类型。只存储表的结构。而其数据文件，都是存储在内存中，默认使用哈希索引
           数据的处理速度快，但是安全性不高，不能建立太大的表
  BLACKHOLE:使用BLACKHOLE数据库引擎的数据表不存储任何数据，只根据数据库操作过程记录二进制日志。它的主要作用是作为MySQL主从复制的中继器
  CSV：数据以CSV格式存储
  ARCHIVE：支持最基本的插入和查询两种功能

~~InnoDB索引和MyISAM索引的区别：
    一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。
    二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。


~~Mysql 主从设计：主从复制（Master-Slave）的方式来同步数据，再通过读写分离（MySQL-Proxy）来提升数据库的并发负载能力，Master负责写，slave负责读
                  MySQL Replicaion机制通过二进制日志文件完成读写节点的同步工作
   上层应用调用
      Spring配置连接分别调用
      lvs配置负载节点

~~MyCat数据库中间件
     1.读写分离
     2.分片策略(ER分片表)
        连续分配
	  自定义数字范围auto-sharding-long
	  按日期天分片sharding-by-day
	  按单月小时分片sharding-by-hour
	  按自然月分片sharding-by-month
	离散分片
	  枚举分片sharding-by-intfile：通过在配置文件中配置可能的枚举id
	  程序指定分区分片sharding-by-substring
	  十进制求模分片sharding-by-substring
	  字符串hash解析分片sharding-by-stringhash：截取字符串中的int数值的hash分片
	  一致性hash分片sharding-by-murmurhash

	 综合类分片规则
	  范围求模分片：先进行范围分片，计算出分片组，组内再求模
	  日期范围hash分片：由于日期取模方法会出现数据热点问题，所以先根据日期分组，再根据时间hash使得短期内数据分布得更均匀
	  取模范围约束分片
	  ASCII码求模范围约束（字符串）
	  固定分片hash（二进制）：类似于十进制的求模运算，区别在于是二进制的操作，是取id的二进制低10位
     2.全局表


~~MySql主主设计：主从的问题是单主存在单点故障，从库切换成主库需要作改动。
                 实例：Mysql+Keepalived双主热备高可用



~~数据库中间件类型
   1.分布式数据库分表分库：最上层的是分布式数据库分表分库中间件，负责和上层应用打交道，对应用可表现为一个独立的数据库，而屏蔽底层复杂的系统细节,Cobar，Mycat，DRDS
   2.数据增量订阅与消费：用户对数据库操作，比如DML, DCL, DDL等，这些操作会产生增量数据，下层应用可以通过监测这些增量数据进行相应的处理,Canal(根据MySQL的binlog实现)
   3.数据库同步（全量、增量、跨机房、复制）：数据库同步中间件涉及数据库之间的同步操作，可以实现跨（同）机房同步以及异地容灾备份、分流等功能,Otter
   4.跨数据库（数据源）迁移:数据库与数据库之间会有数据迁移（同步）的动作 (同数据库类型，不同数据库类型),yugong, DataX


~~DB主从一致性架构优化4种方法
   问题描述：业界通常采用“一主多从，读写分离，冗余多个读库”的数据库架构来提升数据库的读性能，因为同步需要时间，
             所以高并发情况下业务方有可能读取到并不是最新的旧数据
   解决方案
     1.半同步复制：等主从同步完成之后，主库上的写请求再返回。利用数据库原生功能，比较简单，但是主库的写请求时延会增长，吞吐量会降低
     2.强制读主：读写都落到主库，通过cache来提升系统的读性能，但是要改造系统
     3.数据库中间件：中间件记录所有路由到写库的key,在主从同步时间内，如果有这个key上的读请求路由到主库
     4.缓存记录写key：使用cache 代替中间件记录key


~~Oracle Hints：用来告诉优化器按照我们的告诉它的方式生成执行计划，
                1.使用的优化器的类型 
		2.基于代价的优化器的优化目标，是all_rows还是first_rows。 
		3.表的访问路径，是全表扫描，还是索引扫描，还是直接利用rowid。
		4.表之间的连接类型 
		5.表之间的连接顺序 
		6.语句的并行程度
    语法：{DELETE|INSERT|SELECT|UPDATE} /*+ hint [text] [hint[text]]... */
          {DELETE|INSERT|SELECT|UPDATE} --+ hint [text] [hint[text]]...


~~MySql Hint:
	强制索引 SELECT * FROM TABLE1 FORCE INDEX (FIELD1) …
	忽略索引 SELECT * FROM TABLE1 IGNORE INDEX (FIELD1, FIELD2)
	关闭查询缓冲 SELECT SQL_NO_CACHE field1, field2 FROM TABLE1;
	强制查询缓冲 SELECT SQL_CALHE * FROM TABLE1;(如果在my.ini中的query_cache_type设成2，这样只有在使用了SQL_CACHE后，才使用查询缓冲)
	优先操作 SELECT HIGH_PRIORITY * FROM TABLE1;
	滞后操作 update LOW_PRIORITY table1 set field1= where field1= …
	延时插入 INSERT DELAYED INTO table1 set field1= …
	强制连接顺序SELECT TABLE1.FIELD1, TABLE2.FIELD2 FROM TABLE1 STRAIGHT_JOIN TABLE2 WHERE …


~~Mysql执行过程
    service层（连接器->查询缓存->分析器->优化器->执行器）->调用存储引擎的接口（innodb）
    示例
    update XX where id= 2 语句:
    1.执行器先找引擎去ID=2这行，ID是主键，引擎用树搜索找到这行，如果内存存在数据，直接返回给执行器，否则需要先从磁盘读入内存，再返回
    2.执行器拿到引擎给的行数据，将该值加上1，得到新的一行数据，再调用引擎接口写入这行新数据
    3.引擎将这行新数据更新到内存，同时将更新操作记录到redo log，redo log处于prepare状态，然后告知执行器执行完了，随时可以提交事务。
    4.执行器生成这个操作的binlog，并把binlog写入磁盘
    5.执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成


~~MySql日志模块：redo log和binlog
    两种日志的不同：
        1.redo log是InnoDB引擎特有的；binlog是Server层实现的，所有引擎都可以使用，没有crash-safe能力
        2.redo log是物理日志，记录的是 “在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如 “给ID=2这一行的c字段加1”
        3.redo log是循环写的，空间固定会用完；binlog是 可以追加写入的。“追加写”是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

~~Mysql的general_log：执行sql语句的日志

~~Mysql的slow_query_log：慢日志


~~优化Mysql千万级大表
    1.分析: 数据量为千万级，可能达到亿级或者更高
            数据量为千万级，是一个相对稳定的数据量
            数据量为千万级，不应该有这么多的数据


~~存储过程sql server

begin
   declare @commid varchar(50)
    --申明游标
    declare order_cursor cursor 
    for (select COMMODITY_ID from YLYY_COMMODITY where COMMODITY_NAME like '%UP%')
    --打开游标--
    open order_cursor
    --开始循环游标变量--
    fetch next from order_cursor into @commid
    while @@FETCH_STATUS = 0    --返回被 FETCH语句执行的最后游标的状态--
        begin 
        insert into STORAGE_PROCWARE_CONFIGDETAIL(PROCWARE_CONFIGDETAIL_ID,PROCWARE_CONFIG_ID,COMMODITY_ID)
        select NEWID(),PROCWARE_CONFIG_ID,@commid from STORAGE_PROCWARE_CONFIG where ENABLE_FLAG='1'            
            fetch next from order_cursor into @commid   --转到下一个游标，没有会死循环
        end    
    close order_cursor  --关闭游标
    deallocate order_cursor   --释放游标
end
go

~~存储过程oracle

create or replace procedure test_proc is
  v_date date; --定义变量
  cursor cur is select * from ldcode where rownum<10; --定义游标
begin
  select sysdate into v_date from dual;
  --游标for循环开始
  for temp in cur loop --temp为临时变量名,自己任意起
    Dbms_Output.put_line(temp.Code); --输出某个字段,使用"变量名.列名"即可。
  end loop;
  --游标for循环结束
end test_proc;


~~分页sql server
SELECT w2.n, w1.* FROM ARTICLE w1, (　
　SELECT TOP 50030 row_number() OVER (ORDER BY YEAR DESC, ID DESC) n, ID FROM ARTICLE ) 
w2 WHERE w1.ID = w2.ID AND w2.n > 50000 ORDER BY w2.n ASC 


SELECT * FROM ARTICLE w1   
    WHERE ID in   
        (  
            SELECT top 30 ID FROM   
            (  
                SELECT top 1030 ID, YEAR FROM ARTICLE ORDER BY YEAR DESC, ID DESC  
            ) w ORDER BY w.YEAR ASC, w.ID ASC  
        )   
    ORDER BY w1.YEAR DESC, w1.ID DESC

~~分页oracle

 SELECT *
 FROM (SELECT ROWNUM AS rowno,r.*
  FROM(
  SELECT * FROM DONORINFO t
  WHERE t.BIRTHDAY BETWEEN TO_DATE ('19800101', 'yyyymmdd')
  AND TO_DATE ('20060731', 'yyyymmdd')
  ORDER BY t.BIRTHDAY desc
  ) r
  where ROWNUM <= 20*2 
  ) table_alias
  WHERE table_alias.rowno > 20*(2-1);








