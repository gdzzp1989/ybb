~~线性表
    顺序实现
    链式实现
        1.单项链表
        2.双向链表
    一元多项式

~~栈
    应用：
        1.进制转换
        2.算数表达式求值：利用2个栈，一个寄存运算符，一个寄存操作数
        3.迷宫

~~队列

~~串
    字串匹配算法
        1.常规算法
        2.KMP算法

~~数组
    矩阵压缩存储
        特殊矩阵
        稀疏矩阵
            三元组顺序表
            行逻辑连接顺序表
            十字链表
~~广义表：ls=(a1,a2,(b1,b2),a3,...an)

~~树
    二叉树
      遍历递归
        先序：根-左-右
        中序：左-根-右
        后序：左-右-根
    森林
    赫夫曼树：带权路径最小的二叉树，权值*深度，赫夫曼算法构造赫夫曼树

~图
    存储结构
        数组表示法
        邻接表
        十字链表
        邻接多重表
    遍历
        深度优先搜索
        广度优先搜索
    最小生成树算法：利用MST性质的普利姆算法

~~查找
    平均查找长度ASL
    静态有序表查找
        顺序查找:O(n)
        折半查找:O(log2n)
        静态树查找
    动态查找
        二叉排序（查找）树（BST）
        平衡二叉树（AVL树）:O(log n),ASL = [(n+1)/n] * log(n+1) - 1，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
            常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树
            红黑树
                节点是红色或黑色
                根节点是黑色
                每个叶子节点都是黑色的空节点（NIL节点）
                每个红色节点的两个子节点都是黑色
                从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
                平衡过程：变色，左旋，右旋
        B树（平衡多路查找树）:O(logmn)
            子节点最多的个数是m，那么这棵树就是m阶树
            根结点至少有两个子女
        B+树
            非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中
            树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录
    哈希表


~~内部排序
 1.插入排序
     直接插入排序：平均时间复杂度 O(n^2),最好 O(n)，最坏 O(n^2)
     折半插入排序：平均时间复杂度 O(n^2)
     2-路插入排序：平均时间复杂度 O(n^2)
     希尔排序：平均时间复杂度 O(n log n)
 2.快速排序
     起泡排序：平均时间复杂度 O(n^2),最好 O(n)，最坏 O(n^2)
     快速排序：平均时间复杂度 O(n log n)
 3.选择排序
     简单选择排序：平均时间复杂度 O(n^2),最好 O(n^2)，最坏 O(n^2)
     树形选择排序
     堆排序 平均时间复杂度 O(n log n)
 4.归并排序 时间复杂度 O(n log n)
 5.基数排序


~~LRU算法：Least Recently Used，即最近最久未使用的意思。
	   LRU算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小
	实现：利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，
		如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，
		则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。
	改进LRU（缓存污染）:1.访问达到K次才放入缓存