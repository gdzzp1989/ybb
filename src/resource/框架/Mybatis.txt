~~常用标签
   select
   insert:<insert id="insert" parameterType="com.ybb.cms.model.Demo">insert into demo (id, name)values (#{id,jdbcType=INTEGER}, #{name,jdbcType=VARCHAR})</insert>
   delete
   update
   <resultMap>
   <parameterMap>
   <sql>：用来包含数据库的字段,也可以用来做sql片段，使用时通过<include>引入sql片段
   <selectKey>生成主键策略

~~动态SQL的常用标签
   1.<if xxxxx></if>
   2.<choose>
     <when xxxxx></when>
     <otherwise xxxxx></otherwise>
     </choose>
   3.<where></where>：如果该标签包含的元素中有返回值，就插入一个where ,如果where后面的字符串是以AND 和OR 开头的，就将它们剔除。
   4.<set></set>：如果该标签包含的元素中有返回值，就插入一个set ：如果set 后面的字符串是以逗号结尾的，就将这个逗号剔除。
   5.<trim></trim>:where和set都可以用trim标签实现，
      属性意义：
	prefix ：当trim 元素内包含内容时，会给内容增加prefix 指定的前缀。
	prefixOverrides ：当trim 元素内包含内容时，会把内容中匹配的前缀字符串去掉。
	suffix ：当trim 元素内包含内容时，会给内容增加suffix 指定的后缀。
	suffixOverrides ：当trim 元素内包含内容时，会把内容中匹配的后缀字符串去掉。
   6.<foreach></foreach>
      属性意义
	collection ： 必填，值为要选代循环的属性名。这个属性值的情况有很多。
	item ：变量名，值为从法代对象中取出的每一个值。
	index ：索引的属性名，在集合数组情况下值为当前索引值， 当选代循环的对象是Map类型时，这个值为Map 的key （键值）。
	open：整个循环内容开头的字符串。
	close ： 整个循环内容结尾的字符串。
	separator ：每次循环的分隔符
   7.<bind name="XX" value="XXX" />：使用OGNL 表达式创建一个变量井将其绑定到上下文中
   8.<association> :用于高级结果映射，用于一对一和多对一，<collection>是用于一对多的关系

 ~~一级缓存：只存在于SqlSession 的生命周期，方法增加了flushCache= " true ” ，会在查询数据前清空当前的一级缓

 ~~二级缓存：<cache/>开启

 ~~插件开发：实现Mybatis拦截器Interceptor接口并覆写intercept()方法。原理：使用动态代理，为需要拦截的接口实现拦截功能

 @Intercepts
   @Signature (
	type = XXX ,
	method = ”XXX” ,
	args = {XXX})
   )
type的类型（针对4种接口）：
    Executor
    ParameterHandler
    ResultSetHandler
    StatementHandler


~~Mybatis接口绑定
   1.注解方式
   2.mapper.xml方式

~~mapper.xml的namespace是接口的类路径

~~参数绑定：接口方法使用@Param注解


~~Mybatis批量更新
  在sql中使用<foreach>循环动态产生sql

~~配置mapper方式
   1.sqlMapConfig.xml中配置映射文件的位置
     dao接口实现类继承SqlSessionDaoSupport
     spring 配置实现类的bean
   2.在sqlMapConfig.xml中配置mapper.xml的位置
     在spring使用MapperFactoryBean类配置接口实现类（作为MapperFactoryBean一个参数）
   3.配置mapper扫描器MapperScannerConfigurer，配置接口和mapper地址

~~Mybatis执行CRUD过程
  1.SqlSessionFactoryBuilder去读取mybatis的配置文件，然后build一个DefaultSqlSessionFactory
  2.当我们获取到SqlSessionFactory之后，就可以通过SqlSessionFactory的openSessionFromDataSource去获取SqlSession对象

  3.MapperProxyFactory类动态代理dao接口，传给给MapperRegistry，MapperRegistry传给Configuration，Configuration传给SqlSession，
    SqlSession.getMapper(Class)获取对应的MapperProxy代理（改进了动态代理）
    代码路径：
    sqlSession.getMapper(UserMapper.class)-->configuration.<T>getMapper(type, this)-->mapperRegistry.getMapper(type, sqlSession)
    --mapperProxyFactory.newInstance(sqlSession)

  4.得到了代理MapperProxy，具体执行方法时，调用动态代理的方法MapperProxy.invoke,在invoke方法再调用mapperMethod.execute(sqlSession, args)，
    在execute方法中，用sqlSession里的开始执行不同CURD方法
  5.sqlSession调用Excetor具体执行sql


  SqlSessionFactory sqlSessionFactory  = MyBatisUtil.getSqlSessionFactory();  
  SqlSession sqlSession = sqlSessionFactory.openSession();  
  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);  
             userMapper.insertUser(user);  


~~SqlSession的四大对象：
   Executor：
   StatemenHandler：
   ParameterHandler：
   ResultHandler：

~~MyBatis的主要成员
   Configuration：MyBatis所有的配置信息都保存在Configuration对象之中，配置文件中的大部分配置都会存储到该类中
   SqlSession：作为MyBatis工作的主要顶层API，表示和数据库交互时的会话，完成必要数据库增删改查功能
   Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
   StatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等
   ParameterHandler：负责对用户传递的参数转换成JDBC Statement 所对应的数据类型
   ResultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合
   TypeHandler：负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换
   MappedStatement：MappedStatement维护一条<select|update|delete|insert>节点的封装
   SqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
   BoundSql： 表示动态生成的SQL语句以及相应的参数信息


~~mybatis中的#号和$号的区别
   #{XXX} 默认会用引号将参数引起来，预编译处理，防止sql注入
   ${XXX} 单纯替代。


~~Mybatis工具：Tkmybatis

~~Mybatis分页
   内存分页：RowBounds对象，对ResultSet结果集分页
   物理分页：Mybatis-PageHelper插件