~~网络7层模型(OSI模型)   TCP/IP 5层
  应用层
  表示层		  应用层（http,ftp等协议）
  会话层

  传输层		  传输层（TCP，UDP协议等）

  网络层		  网络层（IP协议）

  数据链路层		  数据链路层

  物理层		  物理层


 TCP面向连接，可靠协议（3次握手4次挥手）
 UDP面向非链接，不可靠协议（不管对方状态就发送）



~~第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
  第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
  完成三次握手，客户端与服务器开始传送数据，

~~1.TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
  2.服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
  3.服务器关闭客户端的连接，发送一个FIN给客户端。
  4.客户端发回ACK报文确认，并将确认序号设置为收到序号加1。

~~HttpRequest（Http请求）的格式

  1.请求方法，如GET或POST，表示提交的方式；
  2.URL，请求的地址信息；
  3.请求头信息（包括Cookie信息）
  4.协议及版本；HTTP/1.1
  5.空行
  6.请求内容区（即请求的内容或数据），如表单提交时的参数数据

~~Http1.1版本之前一次连接之后会断开（短连接），1.1之后keep-alive（长连接但阻塞，因为使用了pipeline管道），2.0 信道复用，2.0还支持分帧传输，服务端主动推送


~~HttpResponse
   Cache-Control:public(中间经过的各个代理可以缓存，比如Nginx代理)/private(只有游览器可以缓存)

~~HTTP响应也由三个部分组成，
  1.状态行(HTTP/1.1 200 OK)
  2.响应头信息
  3.空行
  4.响应内容区

~~GET和POST的差别
  GET把参数包含在URL中，POST通过request body传递参数
  GET在浏览器回退时是无害的，而POST会再次提交请求
  GET请求只能进行url编码，而POST支持多种编码方式
  GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（大多数浏览器通常都会限制url长度在2K个字节）。POST无限制。


~~jsp 内置对象
    request
    response
    session
    application
    out: 用于在Web浏览器内输出信息.
    pageContext:对象的作用是取得任何范围的参数
    config:取得服务器的配置信息
    page:对象代表JSP本身
    exception:显示异常信息

~~web.xml加载顺序：context-param -> listener -> filter -> servlet 

~~jsp动态include：<jsp:include page="included.jsp" flush="true" /> 
    两者独立
  jsp静态include：<%@ include file="included.html" %>
    等于包含并显示，变量和主文件共享

~~Servlet：单例多线程,
           当客户端第一次请求某个Servlet时，Servlet容器将会根据web.xml配置文件实例化这个Servlet类。
	   当有新的客户端请求该Servlet时，一般不会再实例化该Servlet类，也就是有多个线程在使用这个实例。
   
   解决多线程环境线程安全
	1.实现 SingleThreadModel 接口
		如果一个Servlet被这个接口指定,那么在这个Servlet中的service方法将不会有两个线程被同时执行，当然也就不存在线程安全的问题
	2.同步对共享数据的操作
		使用synchronized 关键字能保证一次只有一个线程可以访问被保护的区段
	3.避免使用实例变量


~~servlet生命周期
   1.Web容器加载servlet并将其实例化后，servlet声明周期开始
   2.容器运行期init方法进行servlet的初始化
   3.请求到达是运行其service方法
   4.service方法自动派遣运行与请求对应的doXXX方法（比如：doGet，doPost）等
   5.当服务器决定将实例销毁的时候调用destroy方法

~~JSP生命周期
   解析：servlet容器解析jsp代码
   翻译：把jsp翻译成servlet源文件
   编译：编译源文件，生成servlet类
   加载实例：加载servlet类，创建实例，并调用JspInit()
   运行：调用jsp对应的servlet方法
   销毁：调用销毁方法JspDestory()，销毁servlet实例


~~forward：服务器内部的重定向，服务器直接访问目标地址的 url网址，但是客户端并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。浏览器只发送了一次http请求 
           由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者servlet中使用
  redirect：是客户端的重定向。即服务器返回的一个url给客户端浏览器，然后客户端浏览器会重新发送一次请求，到新的url里面，因此浏览器中显示的url网址会发生变化。
            浏览器会发送两个HTTP请求。，因此效率会低于forward。不能共享request域中的数据

~~xml解析
  DOM：加载整个文档树，可以修改，占用内存大，适合增删改
  Sax：采用事件驱动模式，边读边对文档进行处理.适合读取，对内存耗费比较小
  JDOM：java平台
  DOM4J：java平台

~~非对称加密的加密算法：特点是私钥加密后的密文，只要是公钥，都可以解密，
  但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人

~~HTTPS：比http请求多了一层SSL/TLS协议，客户端先向服务器请求得到一个数字证书(CA证书里面包含了数字签名，公钥等信息)从而得到与服务器通信的密钥，然后用对称加密算法通信
         得到密钥过程（非对称加密算法）：客户端再使用第三方机构的公钥(浏览器和操作系统自带)解密CA证书里的公钥(第三方机构的私钥加密服务器的公钥后的密文)
                                         数字签名可以防止同一机构颁发的不同证书被篡改问题

         HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法(不同客户端的公钥不同)，
         但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，
         会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。
         这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。


     以浏览器为例说明如下整个的校验过程：
	1.首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
	2.浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 
	3.如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
	4.如果找到，那么浏览器就会从操作系统中取出  颁发者CA的公钥，然后对服务器发来的证书里面的签名进行解密
	5.浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比
	6.对比结果一致，则证明服务器发来的证书合法，没有被冒充
	7.此时浏览器就可以读取证书中的公钥，用于后续加密了


~~TCP粘包/拆包
	TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。
	TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，
	也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

	解决：  消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
		在包尾增加回车换行符进行分割，例如FTP协议；
		将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；

~~WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。
   在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。


~~websocket 跟 socket 的区别。
   Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，
	让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。
   WebSocket 则是一个典型的应用层协议。
   总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。


~~SockJS是一个浏览器JavaScript库，它提供了一个类似于网络的对象。SockJS提供了一个连贯的、跨浏览器的Javascript API，
  它在浏览器和web服务器之间创建了一个低延迟、全双工、跨域通信通道。
  好处在于提供了浏览器兼容性。优先使用原生WebSocket，如果在不支持websocket的浏览器中，会自动降为轮询的方式。 

~~STOMP：直接使用WebSocket协议开发特别繁琐，所以使用STORM协议来替代(STORM是WebSocket的子协议)
         STOMP在WebSocket之上提供了一个基于帧的线路格式层，用来定义消息的语义。STOMP帧由命令、一个或多个头信息以及负载所组成。
		>>> SEND
		destination:/app/marco
		content-length:20
		空行
		{"message":"Maeco!"}


~~使用HttpOnly提升Cookie安全性


~~提升Cookie安全性
   1.对保存到cookie里面的敏感信息必须加密
   2.设置HttpOnly为true
   3.设置Secure为true
   4.给Cookie设置有效期
   5.给Cookies加个时间戳和IP戳，实际就是让Cookies在同个IP下多少时间内失效


~~CSRF:CSRF跨站点请求伪造(Cross—Site Request Forgery),
       攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作
   防御CSRF攻击: 1.验证 HTTP Referer 字段
                2.在请求地址中添加 token 并验证
                3.在 HTTP 头中自定义属性并验证
